## 背包问题（Knapsack problem）{docsify-ignore}

![knapsack](./img/knapsack.png ':size=277×240')

给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。

我们有`n`种物品，物品`i`的重量为`wi`，价格为`pi`。
我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为`W`。

* 如果限定每种物品只能选择0个或1个，则问题称为`0-1背包问题`。
* 如果限定物品`i`最多只能选择`bi`个，则问题称为`有界背包问题`。
* 如果不限定每种物品的数量，则问题称为`无界背包问题`。

### 0-1背包问题

另`f(i, W)`表示前`i`件物品放入一个容量为`W`的背包可以获得的最大价值。

则状态转移方程：`f(i, W) = max(f(i - 1, W), f(i - 1, W - wi) + pi)`

我们考虑第`i`件物品是否放置的两种情况：

* 如果没有放入第`i`件物品，那么能得到的最大价值就等价于“将`i - 1`件物品放入容积为`W`的背包中，能获取到的最大价值”，表示为公式即`f(i - 1, W)`

* 如果放入了第`i`件物品，那么能获取到的最大价值就等价于“将`i - 1`件物品放入容积为`W - wi`的背包中所获取到的最大价值加上第`i`件物品所具有的价值`pi`”，表示为公式即`f(i - 1, W - wi) + pi`。

最终我们要取这两种情况中的最大值，即`max(f(i - 1, W), f(i - 1, W - wi) + pi)`

#### 递归处理方法

```js
const objs = [
  [4, 15], // [wi, pi]
  [8, 6],
  [5, 18],
  [16, 22],
  [7, 28]
]
function knapsack(objs, w) {
  if (w <= 0 || objs.length === 0) { // 没有空间或没有物体可放
    return 0;
  }
  let res = 0;
  for (let i = 0; i < objs.length; i++) {
    const others = objs.filter((o, j) => j !== i);
    if (objs[i][0] > w) { // 这个物体盛不下
      res = Math.max(res, knapsack(others, w)); // 尝试放置剩下的物品
    }
    res = Math.max(res, knapsack(others, w), knapsack(others, w - objs[i][0]) + objs[i][1]);
  }
  return res;
}
```

### 有界背包问题

### 无界背包问题

无界背包问题可以转换为0-1背包问题，因为背包容量有限，同一物品`i`放置次数小于等于`w / wi`，因此无界背包问题可以作为“包含多个重复元素”的0-1背包问题


### 参考资料

* [维基百科](https://zh.wikipedia.org/wiki/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98)